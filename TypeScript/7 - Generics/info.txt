GENERICS:
Generics are types that combines multiple types to create an accurate datatype.
One of the Generics we already saw is:
    let name: Array<string> = ['max', 'jassy'];
here, array type is working with string and saying, it should be an array full of strings only.

They are used to make our types flexible.
    type DataStore<T> = {
        key: T
    };

    let store1: DataStore<string | boolean> = {
        key: "hello",
    };

    let store2: DataStore<boolean> = {
        key: true
    }

here, <T> can be anything, T is a convention, also means Type.
Its basically a placeholder which at the time of defining, if we dont know, we can just use it directly, and pass the actual types while using it. benefit is, along the way, I can store any kind of data based on requirement.

Just to know, we can add any no. of placeholders:  eg:
    let DataStore<T, U, > = {...}


    // with functions:
    function merge<T>(a: T, b: T) {
        return [a, b]
    }
    const nos1 = merge<number>(1,2); // or
    const nos = merge(1,2);

    // like we do with generic array types, we can omit type name as ts have inferred type 
    const arr = [1,2,3] // assumes its a number array

Here, we added generics with functions.
We can use <T> placeholder, in our args and inside, with what we pass during the call of that function.
rem, how we can omit the <string> with array, as ts itself assumes the type on its own, similary, ts can also do the same for our generic types, wherein we can omit the <number>, by looking at the values, ts on its own, assumes the values.
you must think, that why cant we use 'any' instead? 
Good. We can use any, but then we wont get that auto completion as ts wont know what types are being used, hence type-checking; which is what typescript is so popular for, will be disabled for any object.
below are some differentatiation points:
any:
Effectively disables type checking.
Allows values to be of any type.
Can be useful when migrating JavaScript projects to TypeScript or when dealing with external libraries without type definitions.
Should be avoided when possible, as it sacrifices type safety and can lead to runtime errors.

Generics:
Create reusable components that can work with different types while preserving type information.
Allow you to write flexible code without losing type safety.
Enable the compiler to infer types, reducing the need for explicit type annotations.
Help enforce type constraints, ensuring that the code behaves as expected.
Used to reduce code duplication and improve maintainability.


    // with functions:
    function merge<T, U>(a: T, b: U) {
        return [a, b]
    }
    const nos1 = merge<number, string>(1, 'numberinstring'); // or
    const nos1 = merge(1, 'numberinstring'); // or

We can add any no. of placeholders.



=> Adding constraints in generic types:

while adding placeholders, we can add constraints by adding any type, like array, string, number. It tells ts that the args can be any type of object, but has to be an object only.

    function mergeObj<T extends object>(a: T, b: T) {
        return {...a, ...b}
    }
    const merged = mergeObj({a:1}, {b:2})
    const merged2 = mergeObj(1,2) // error


     function mergeObj<T extends number>(a: T, b: T) {
        return {...a, ...b} // will throw error here, as number cant be spread.
    }
    const merged = mergeObj({a:1}, {b:2})  // error
    const merged2 = mergeObj(1,2)


// extending 2 args: 

    // more recommended:
    function mergeObj<T extends object, U extends object>(a: T, b: U) {
        return {...a, ...b}
    }
    // hover over mergeObj, you'll see more simpler pairs of object compared to above one
    const merged = mergeObj({a:1}, {b:2}) 


// generic classes & interface

// generic class:
    class User<T> {
        // constructor(public id: string | number | object){}
        constructor(public id: T){}   
    }
    const u1 = new User("1")
    const u2 = new User(1)
    const u3 = new User({id:1})


    // generic interface
    interface User<T> {
        id: T
    }
    const u4: User<string> = {
        id: "1"
    }


