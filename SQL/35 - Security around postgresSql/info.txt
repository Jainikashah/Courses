CODE IS IN PREVIOUS CODE(33) FOLDER ONLY, AS WE ARE WORKING ON THE SAME PROJECT.

what's the issue here?
    static async findById(id){
        // REALLY BIG SECURITY ISSUE
        const { rows } = await pool.query(`SELECT * FROM users where id = ${id}`)
        return toCamelCase(rows)[0] // to get the first row only; though it will either be 1 or null rows only 
    }

Here, lets make a request via our postman:
    localhost:3005/users/1; drop table users

Wait a minute, this doesnt look like a valid query. And it surely will give an error in our terminal.
But after running the query, you'll see, our table is no longer there!
Booommmm! All our hard work is in vain.
But why did that happened?

because:- our query got replaced from-
    `SELECT * FROM users where id = ${id}`
    to
    `SELECT * FROM users where id = 1; Drop table users`

This is called SQL INJECTION EXPLOIT. SO never, ever insert the user-provided value directly into a sql query. There are few safe ways to do so. 

2 SOLUTIONS:-
- Add code to 'sanitize' user-provided values to our app
- Rely on postgres to sanitize values for us.

1. We write the code to sanitize the code and make it safe
2. postgres does it for us.
Most of the times we should go with the 2nd solution only. But there are times when sol1 is needed aswell.

Lets see how to do it with option2:- That is how to let postgres safeguard our queries-
We instead of giving the entire query to pg(the module we insteall rem?), we separate it our into 2 parts.
    - select * from users where id = $1
    - ['123']

Here, $1 means, replace the value with the value provided inside the array. $1 - first item, $2 - second item and so on..

What pg does is:-
- it takes our query creates a prepare statement like this:-
    prepare anyNameGivenByPg (string) as select * from users where id = $1
                    execution of above statement
    execute anyNameGivenByPg('123')

anyNameGivenByPg - a random name given by pg to the query
string is the datatype for the $1 value
prepare is a keyword that says, here's a query but dont run it right away, I'll let you know when to run.
to run, pg throws an execute statement alongwith the name - anyNameGivenByPg.

When we run a prepare statement in postgres, it knows what we are trying to do. and so, even if we send drop table users inside the id param, ppstgres will just replace it with id = 'drop table users' which will be fasle. It wont run it as query but as a comparison value onlyy.

So, our problem is solved here!
One downside is, we cannot replace tablenames or identifiers (columnnames) with that $ sign. Only values like string or integer (actual values) can be replaced.


Lets do in practical:-
- First delete the socialnetwork db and create a new one again -> run the migration file -> and insert some values.
(DATABASE_URL=postgres://postgres:Admin@123@localhost:5432/socialnetwork npm run migrate up )

    from (user-repo.js)
        // const { rows } = await pool.query(`SELECT * FROM users where id = ${id}`)   
    to
        const { rows } = await pool.query(`SELECT * FROM users where id = $1`, [id])

    from (pool.js)
    query(sql){
        return this._pool.query(sql)
    }
    to 
    query(sql, params){
        return this._pool.query(sql, params)
    }

In pool.js we are actually wehre making the pool query function call remember, its a class instance we are using everywhere.

LETS TEST IT OUT in postman:
    localhost:3005/users/1 
works great

    localhost:3005/users/1;drop table users
throws an error. that type integer doesnt match the params.
and nothing happens to our table. goooood!!!

always rememebr, whenever we are trying to make use of a value, any type of value, could be user-provided or any value generated by your code, should be written with that $ sign syntax only.

=> Lets move to our next api call.
- To test a post req in postman
   select post -> select body -> select raw - >select json -> add your body and done!


// insert function - user-repo.js
    static async insert(username, bio){
        const { rows } = await pool.query(`INSERT INTO users (username, bio) VALUES ($1, $2) returning *`,
        [username, bio]); 
        return toCamelCase(rows)[0]
    }

// handling post route - users.js
    router.post('/users', async (req, res) => {
    // req.body - returns the body we pass (payload)
    const { username, bio } = req.body
    const user = await userRepo.insert(username, bio);
    res.send(user)
})

- returning * means - by default insert query donot return the value it has inserted and so to get that, we need to write this syntax.
- req.body gives us the payload.


=> PUT REQUEST:
USER-REPO.JS
     static async update(id, username, bio){
        const { rows } = await pool.query(`UPDATE users SET username = $1, bio = $2 WHERE id = $3 returning *`, 
        [username, bio, id])
        return toCamelCase(rows)[0]
    }

// ROUTER FILE
    router.put('/users/:id', async (req, res) => {
        const { id } = req.params;
        const { username, bio } = req.body
        const user = await userRepo.update(id, username, bio);

        if(user){
            res.send(user);
        }else {
            res.sendStatus(404)    
        }
    })
Its just explanatory!
To run - localhost:3005/users/1 (select put and add body)

=> DELETE :-
    static async delete(id){
        const { rows } = await pool.query(`DELETE from users WHERE id = $1 returning *`, [id])
        return toCamelCase(rows)[0]
    }

    router.delete('/users/:id', async (req, res) => {
        const { id } = req.params;
        const user = await userRepo.delete(id)
        if(user){
            res.send(user)
        }else {
            res.sendStatus(404)
        }
    })
to test in postman - localhost:3005/users/2 (select delete)