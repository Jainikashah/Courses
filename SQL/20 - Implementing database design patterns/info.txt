Implementing database design patterns:-

- We got the design ready. Note. Design is not the ultimate guide. We might make some change along the way as we create and update our databases.

In postgres -
- create a new db, instagram

USERS TABLE:-
create table users (
	id serial primary key,
	created_at timestamp with time zone DEFAULT current_timestamp,
	updated_at timestamp with time zone DEFAULT current_timestamp,
	username varchar(30) NOT NULL,
	bio varchar(400),
	avatar varchar(200),
	phone varchar(25),
	email varchar(40),
	password varchar(50),
	status varchar(15),
	check(coalesce(phone, email) is not null)
)

- default current_timestamp - means, if nothing is provided, current_timestamp will be cnsidered which is the time the record is created. 
- here, created_at and updated_at will be same at the time of creation. Its then when we update a user, it'll change.
- Not null means the value is compulsory. empty strings ("") are values.
- we want either phone or email. so we have coalesce. rem coalesce, it will return the first not null value from the args.
if both are null, it'll return null. and we have a condition there of is not null. 


Rules of constraints:-
It doesnt matter if a value exists
- no constraints
We want a value everytime from the user only (mostly th engineer)
- Not null
Always want a value,not necessary from the user always. If provided take that, or give a default one.
- Not null + Default


POSTS_TABLE:-
create table posts (
	id serial primary key,
	created_at timestamp with time zone DEFAULT current_timestamp,
	updated_at timestamp with time zone DEFAULT current_timestamp,
	url varchar(200) NOT NULL,
	caption varchar(240),
	lat real check(lat is null or (lat >= -90 and lat <= 90)),
	lng real check(lng is null or (lng >= -180 and lng <= 180)),
	user_id integer not null references users(id) on delete cascade
)

checks:-
-90 < lat < 90
-180 < lng < 180
90 and 180 are the values that are at and lng should belong to. 

Remember our what validation to keep on server and what on db lecture?
- If the value changes often : server
- If rules for validation are complex : server
- If we want to make sure we have the right type or domain (between a range) : db
so thats what we are doing with lat and lng here.

for user_id we always want to make sure that its not null, otherwise who the post will refer to. we cant let it just hang in there. also if we ever delete the user from users table, we want to delete its posts as well, so delete cascade.


Comments table:
create table comments (
	id serial primary key,
	created_at timestamp with time zone DEFAULT current_timestamp,
	updated_at timestamp with time zone DEFAULT current_timestamp,
	contents varchar(240) not null,
	user_id integer not null references users(id) on delete cascade,
	post_id integer not null references posts(id) on delete cascade
)


Likes table:-
create table likes (
	id serial primary key,
	created_at timestamp with time zone DEFAULT current_timestamp,
	user_id integer not null references users(id) on delete cascade,
	post_id integer references posts(id) on delete cascade,
	comment_id integer references comments(id) on delete cascade,
	check(
		coalesce((post_id)::Boolean::integer, 0)
		  +
	 	coalesce((comment_id)::Boolean::integer, 0)
	  	= 1
		 ),
	unique(user_id, post_id, comment_id)
)

here, we have made a check that either post_id or comment_id should be required. and so we take post_id, convert it to boolean (if null - false, true otherwise) and convert it again to integer (null, 1, 0). if its null then it'll pass 0 (the 2nd arg) other wise 1. and will + the comment_id here with the same way. if:-
1 + 1 (false, we dont want both of them to be true)
1 + 0 (true)
0 + 1 (true)
0 + 0 (both are null, not valid)
we could use what we did in email and phone no above, but we dont want both to be true either. we just exactly want one, and hence there's this weird syntx come in.

for uniqueness, we checked all three as a whole should be unique. so that the same user doesnt like it twice or more.


photo_tags:-
create table photo_tags (
	id serial primary key,
	created_at timestamp with time zone DEFAULT current_timestamp,
	updated_at timestamp with time zone default current_timestamp,
	user_id integer not null references users(id) on delete cascade,
	post_id integer not null references posts(id) on delete cascade,
	x integer not null,
	y integer not null,
	unique(user_id, post_id)
)

we dont want to let the user tag same user twice, hence unique constraint added.


caption_tags:-
create table caption_tags (
	id serial primary key,
	created_at timestamp with time zone DEFAULT current_timestamp,
	user_id integer not null references users(id) on delete cascade,
	post_id integer not null references posts(id) on delete cascade,
	unique(user_id, post_id)
)


hashtags:-
create table hashtags (
	id serial primary key,
	created_at timestamp with time zone DEFAULT current_timestamp,
	title varchar(20) not null unique
)

hashtags_posts:-
create table hashtags_posts (
	id serial primary key,
	hashtag_id integer not null references hashtags(id) on delete cascade,
	post_id integer not null references posts(id) on delete cascade,
	unique(hashtag_id, post_id)
)

followers table:-
create table followers (
	id serial primary key,
	created_at timestamp with time zone default current_timestamp,
	leader_id integer not null references users(id) on delete cascade,
	follower_id integer not null references users(id) on delete cascade,
	unique(leader_id, follower_id)
)