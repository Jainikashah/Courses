=> Javascript engine:-

- There are ton of js engines like v8, chakra, spiderMonkey, etc.
- It takes our js code and converts it into machine readable, as computers doesnt understand js directly. It works like a translator basically.
- v8 engine is written in js & c++
- Brendan Eich; who worked at Netscape, created js language & the engine - spiderMonkey; which firefox till date uses.
- Js is a single-threaded language; uses call stack to queue tasks.
- ECMASCRIPT is a governing body of javascript, which tells us what you can do with js, and make it standardized (i.e. same at all browsers).


=> Interpreters vs compilers:-
Initially js used an Interpreter. basically Interpreter take one line of code -> runs it -> go to next line. It transaltes our code on the fly. Well, thats how we expect it to run like right?
Vs  
Compiler takes our whole code and converts it into another language (in lower-lang) ahead of time.
Most of the languages does both, interpretes the lnaguage & compile it. 

Pros & Cons:-
- With Interpreters, every line of code is executed one by one, which makes it faster to start with since there's no need to go through the entire code first & convert it into another lang. But with this Pro, one con is, that if we have a function lets say, that adds 4+5, and we call it multiple times, interpreters will execute the function every time.
- Whereas with compilers, it takes time to start up as for the added step of converting the entire code, its good with situtations where a function's input & output is always same. It doesnt runs it everytime, instead it stores the result and returns the same. 
Hence, at beginning, interpreters are fast, but compilers are better optimized along the way.

But what if we want the best of both world? Well, there is a thing like that, called - JIT Compiler (JUST IN TIME).
Remember v8 engine, it uses JIT compiler to run fast.
How it works? JIT compiler uses an Interpreter, and generates byte code (which is not 1- as optimized as compiler's code, 2- not as low language as compiler's code). There's a profiler that checks the code that it interpreted, and sees if there's any need of optimization needed, if there's any code that's repeated, if so, it sends that code to compiler & compiler generates optmized code which is faster & machine level code as well. And thus, all these operations makes Javascript a lot faster language as we are using the best of both worlds.

Note: Byte code is not as low level as machine code. Machine code can be run on any device, whereas byte code cant. It requires a software that converts it into machine code. 

So is js an interpreted language? (MOST COMMON QUESTION)
- Sure it is, initially js was an interpreted language but as time progresses, performance became an issue. It became slower & slower, and so compilers were introduced. Thus Javascript combined both Interpreter and Compiler to get the best of both the world. So Browsers started mixing compilers called JIT-Compilers for just-in-time compilations to make the engines faster.
Hence, we can say that js is an interpreted lang, but technically it uses compiler BTS.

 https://dev.to/robiulhr/is-javascript-compiled-or-interpreted-language-l20
- checkout this page, what a detailed explanation with example on whether its an interpreted or a compiled language?


Better code:
- There are few coding habits to watch out for us. Not using these can helps in making our code faster. So to help js engine, avoid using below keywords:-
- Eval()
- arguments ; use parameter destructing instead
- for in loops ; use object.keys() instead
- with
- delete keyword

Here's a link that says more about these optimization killers : https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments

Code that makes optimization better-
- Inline caching
- Hidden classes (assigning obj properties should be in order, otherwise it'll take time for compiler)

Read more about the two - https://richardartoul.github.io/jekyll/update/2015/04/26/hidden-classes.html

NOTE: MAKE YOUR CODE PREDICTABLE. so compiler doesnt see any surprises along the way and makes optimization better & as it has assumed.


=> Web assembly
- why not just use machine code from the beginning?
lets run the compiled code in the browsers directly only, cant we do that? I mean it could save us a lot of time with all these compilers and interpreters in between. We just give the mchine code directly to our websites only. it would be pretty fast, wont it?. well, we cant
Because (a) - either the compilation has to be very fast. Remember, the js code is sent from servers to the client. (b) or all the leading browsers like chrome, firefox, safari has to agree on a binary executable format/standard that can understand this machine code. Back in 1995, browsers didnt agreed to this. Even now, browsers have diff way of doing things.
But now, we have something that can be game changer - WEB ASSEMBLY.
A low-level executable format that will be run on every browser, making it really fast. 


=> Call stack & Memory heap:-
