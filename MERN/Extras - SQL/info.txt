DATABASE - SQL:-

Earlier notebooks and pen were used to maintain data. (Limitation:- More data and no filters)
Then came excel, Overcame Limitation of notebooks. (Limitation:- Handling complex data like a user returned the product and reordered it again)
Then we have Databases. The best of all. Distributed data in tables and SQL statements to filter the data as per the need.

A playground for running sql statements: https://www.w3schools.com/sql/trysql.asp?filename=trysql_select_all

A db is just a hardware & software that manipulates the data.

How the data is stored?
    Example of an ecommerce store:-
- A customer table, with a unique customerid with all the customers we have.
- A products table, with a unique pid with all the products we have.
- An orders table, with a unique orderid, with all the orders we got. It also has a customerid and pid with the related info. Thats how we create relationships between tables. So that with 1 orderid, we can get the customer details and the product details.

A relational db, where we can have massive data and organize it in a way that is pretty understandable. 


=> Types of databases:-
- We have a ton of dbs. Some of the popular ones are:- Mysql, postgres, casandra, mongo, oracle, etc.
Types:-
- Relational: postrgres, mysql, miscrosoft sql. More in ecommerce sites
- Document: mongodb, couchdb, firebase. More with scalability
- Key Value: reddis, dynamodb. Simplest way to access data. 
- Graph: aws neptune. rare and complex. good for data with multiple relations like a social media app.
- Wide columnar: Google's big data. fairly new. 
 
Database:- A db is a sytem; hardware & software that allows a user to store, organize & use data.

Playground for sql:- DB Fiddle.

=> SQL:-
A programming lang to talk to our server. We have queries/sql statement that we ask the server and get the appr data.
eg: 
    SELECT * FROM USERS
    SELECT NAME FROM USERS
    SELECT NAME FROM USERS WHERE ROLE="MANAGER"
* - everything
SELECT * FROM USERS - sql query/statement
USERS - table name
WHERE ROLE="MANAGER" - clause
NAME, ROLE - identifier 
ROLE="MANAGER" - condition


=> Declarative & imperative:-
Declarative: What will happen - I want this, get me this. get me a sandwich.
Imperative: How it will happen - I'll tell you step by step how to get me this. cut the bread, add veggies, palce it together, give it to me.

Declarative - SQL
Imperative - JAVA
Python can be both of them.


=> HISTORY:-
SQL = SEQUEL
Earlier, we use to call it SEQUEL - Structured English Query Language. But due to copyright conflict, it changed to sql = Structured Query Language.
Technically 1970, but formalized in early 80s.
A programmer from IBM Edgar Frank Codd wrote a paper that sets a standard of sql, “A Relational Model of Data for Large Shared Data Banks,” in 1970. Later two men, Raymond Boyce and Donald Chamberlin created the original language and software to implement his vision.
https://www.youtube.com/watch?v=KG-mqHoXOXY - a cool video on history of databses.


=> SQL Standards:-
A bunch of people creatig new rules for a language is called standardization and sql is standardized. And softwares like postgres, mysql, oracle are built upon it with some additional fancy features to attract developers and use their softwares more.


=> Basics:-
A table has a name, and several rows and columns. 
Single column is called attributes.
Collection of ALL columns is called degree.
The datatype of columns is specific to a type only. The type in sql is called domain/constraint.
eg- The id attribute has number constraint.

Row/s is/are called tuple/tuples.
The tuple data has to follow the attribute constraint.
The collection of ALL rows is called cardinality.


=> Primary key:-
Something that uniquely identifies each row. 
Foriegn key is used to have a reference to other table. That's how we have relationships.
A foreign key is a primary key of another table.


=> Relational vs NoSql. (Postgres Vs MongoDB)
- In early 2000s, mongodb took over the relational dbs, due to its ability of horizontal scaling. But now, other relational dbs like postgres are becoming more useful. Even in the latest trends, we can see postgres is growing rapidly.
In mongo, the infomration that is related is stored together in an object.
In relational, data is splitted into multiple tables. (even if its related) and thats why horizontal scaling is tedious in sql.
In relational, we have unique data only, no duplicated data is there. Data interity is pretty good. Also its declarative and flexible. The cons are:- a schema, we need to have a schema beforehand and has to maintain throughout the years.
In nosql, the data can be duplicated over all many documents. With nosql, we can easily add new schema during the implementation. And the data thats related is stored at one place, making it good with horizontal scaling.

what to use when?
- When we have multiple relations, go with sql otherwise nosql.
Lets say, we have linkedIn profile, my own profile doesnt have much relationships, all it shows is my information and for that mongodb is great. I can easily add/edit my data.
But if I am using a CMS or blogging site like wordpress, I'll go with postgres, because there'll be multiple users visiting and commenting on my blogs, which creates a lot of linking.


=> Scalability:-
Handling growing amt of data.
Vertical scaling:- 
Adding more capacity, power to a single machine. Like more disk space, or rams. Relational db are good with Vertical scaling. Limitation is that we can grow it to a certain limit, I mean how much in practical can we add in one single machine. there's always a limit.

horizontal scaling:- here, we add more databases. nosql is good in horizontal scaling. Also with adding machines, we have to take care of data integrity. The data should be consistent in all the databases. Its complex to manage horizontal scaling comapre to vertical.

=> Sharding:-
The idea of splitting the requests in multiple databses. Eg, the users starting from a-j will make requests to db1 and others will make to db2. The splitting is very complex and can be based on multiple factors like based on users, or logically, or based on data, etc. This is done by a system like routing system that decides which query will go to which db. 
Basically distributing the queries to multiple databases so the load is not on one single db. and more data is possible to be stored as we have so many machines to store on, is called sharding.