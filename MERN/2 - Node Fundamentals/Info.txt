FUN FACTS:-

- Run `node` command in terminal and now you can write js in your terminal. Type .exit or ctl c (twice) to get the terminal back.
- To run a file directly, `node hello.js` cmd works.
- Node odd number version might have latest features, but they dont have LTS(long time support). Whereas with even nos. they provide lts. eg Node 15 (no lts), node 16 (with lts)
- REPL : Read -> Eval -> Print -> Loop

Fundamentals:-
- cmd `process` 
A bunch of diff info about the node process. like - argv (for command line args)
To drill down the process cmd - `process.argv`

To run node file : `node hello.js`

Example of cmd line args:-
    const activity = process.argv[2];
    if(activity == 'learn') console.log("Time to write some code")
    else console.log(`Is ${activity} more fun than coding?`)

cmd:    
    node file.js learn   // time to write some code
    node file.js dancing  // is dancing more fun than coding?


- How is node diff from js?
Initially js use to run on browsers only. But when chrome decided to make V8 Engine open source, ryan dahl; the creator of node, took advantage and made js run outside the browser. And now we can run in to on our computers, mobile phones and even to create robots. 

- But whats the difference for developers here?
Well features like window; which contains alert, prompt, document, etc. functionality will no longer available to us in node, becuase these are browser-specific features and not that's inside of the js library.
Instead node has something call - `global`
It has a lot of functionality to use, similar to window for browsers.
cmd: `global.process`
cmd: `global.console.log`

yes, all these process, console.logs, etc comes from global only. Its just that we dont need to specify global everytime. Its the by default one that node looks for in.

Replacement of browser specific features in brief-
window   --->   global
document --->   process
history  --->   module
location --->   __filename
navigator -->   require()

Apart from this, node also allows us to read & write files, create & access servers, etc. that makes it diff from browser-specific. 

Node basically includes following APIs- javascript engine (all js execution like 2+2), file system, http request (making api calls), path (looking into our computer), cyrpto (encyrpting & decrypting). 
The core functionality of the above APIs lies in "libuv". A highly optimized C library that handles the input & output functionality and deals with computer's OS.
V8 engine & Libuv are the most important internal components of node.

Node Js is an open source library. We can check the entire code that is written in lib & src folder of node git repo. Go through it, its cool. Functions like fs.open, read etc's code is written in it. THE ACTUAL BTS CODE.
- github.com/nodejs/node     // the node repo

libuv - we can check the code of this library too, under github. 

- Nodejs Bindings:- 
Lets say I want to read a file, I used fs.readFile() Function. Now, I have written the code in js. Node js API - fs, is written in js, but the computer's actual file system doesnt understand js. 
fs.readFile() - This method is not part of javascript. It's provided to v8 as part of the node.js runtime. So javascript does not know how to read a file from disk but C++ does. So when we use javascript code and node.js to read a file from disk it just defers all of that to the C++ function that can actually read the file from disk and get the results back. 
This c++ code is call node js bindings.
 
-> The overall flow:-
Js code -> Node Js APIs(like fs, http, path, crypto) -> Node Js Bindings -> Libuv



=> Synchronous vs Asynchronous:-
- I want to get hired as a developer, the steps are:-
 Learn html
 learn js
 learn node
 get hired
 Here I go one by one, finish one lang at a time fully. This is a synchronus process.

 Now in async, I learnt html, then js and alongwith js I started node. And in middle I was giving interviews and got hired at a company. Here my goal is achived, but even after I am learning js and node js to its best. This is a aysnc process where I am performing multiple tasks at a time. 
 Node js is pretty good at doing this. At handling multiple tasks Asynchronously.


=> Blocking vs Non-Blocking:-

    json.stringify(.........)
    console.log("hello, I am running late")
The above code is blocking code. How? Well, blocking code is the one that stops further code to be run before its completion. So here the entire object will be stringified and the xyz operations are done, then only the below code will be runned.
 
    setTimeOut(() => {...}, 1000)
    console.log("Heloo, I am early this time")
The above setTimeOut code is non-blocking as the callback runs in background, it will allow the below code to be run simultaneously.


=> Is javascript a synchronus or Asynchronous language?
Javascript is a synchronus language. It executes code one after other. But then how are we writing async code all this while? Becuase node APIs is what lets us write async code in js. In browser, it was the window object that allowed us to write async code. Javascript as a language doesnt come with async functionality. 
Javascript is a synchronus, single-threaded language but with the help of event-loops & promises, we can do async programming.


=> Is node multip-threaded?

A process - basically a container that holds the code, memory and call stacks that is needed to execute our task.
process code:-
    firstFun() { ... secondFun() }
    secondFun() { ...return; }
    new Thread(firstFun)
    new Thread(secondFun)

new Thread - creates a thread with a call stack. Call stack holds functions calls and the sequence of how it will be executed. 

call stack for thread1:-
    secondFun()                     
    firstFun()
after the secondFun is executed its returned and the control goes back to firstFun and the remaining code of firstfun is executed and after done, its removed from call stack too.

same goes for thread2. Note:- threads donot run together. They are independent of each other. though they share the same process(which means same memory & same code), they are independent. My first thread can run faster than second. But threads can run simultaneously thats why we call it multi-threaded. That independent chunks of code run on multiple threads to make the program fast and smooth.
Java, c++ supports multi-threaded.
The problem with multi-threaded is that its not that easy. Developers could end up in deadlocks. where 2 or more threads are waiting for an event that'll never occur or are dependent on each other only.
So, js developer made it single-threaded language. 


Well than how node is allowing us to open file system and make http request together?  
Node has one main thread. This one thread runs v8 engine, our node apis, and libuv's imp part i.e. eventloop.
Libuv has 2 main async I/O operations to perform. 1- file system & 2- network (getting data from the other computers via networking)
For these, libuv has event loop that takes care of these async functions. And notifies when its done. This doesnt create blocking code in our main thread. 
Now what happens in this eventloop?
- Some tasks like network events eg- fetching data from a server, are done directly by our OS only. As OS does it very well, node lets such tasks done by os only.
- For other async tasks, its given to thread pool. Since libuv is written in C, it supports multiple thread. In thread pool, there are few threads available for our program to use beforehand. It keeps it pre-ready. This prevents our cpu to create & destroy threads repeatedly. If we run out of our pre-ready threads, then our program has to wait until therads are emptied. 
NOTE:- Libuv doesnt use thread pool for every async task. It rather uses OS, and its kernel to perform actions like communicating with diff computers. 
Thus, all of this makes Node js multi-threaded via libuv library.
And with this, we as developer dont need to take care of threads and stuff as all this is runned BTS by the libuv lib only.  


=> Event loop:-
One of the most imp part of node runtime. The one that is responsible for all those callback functions, which allows us to write async code, even though js is single-threaded.
Event loops - a loop that processes all the async callbacks, it waits untill the code triggers the callback function. For any hard part like fs or network it passes it to thread pool or OS as we saw earlier. Event loop runs as long as our node app is running. 


=> Callback queues:-
Lets say we have a setTimeOut function callBack1(). It is added to the callback queue and after the event occurs that triggers it, it gets removed from the queue. The imp note here is that if I have 2-3 callback functions, that it gets added to the callback queue and the approach of FIFO is used, where the one that gets in first, gets out first. 


=> The phases of event loop:-
You know what? There's not just 1 callback queue that would handle all the callbacks in our program, instead there are several of them. One for each phase of event loop. Now what's this phase thing?
 
 Event loop phases:-
 - Timers
 - I/0 callbacks
 - setImmediate
 - Close callback

 These are just categories into which our types of callbacks are divided into. There are few more phases but they are mainly an internal part of node and has nothing to do with js.

There are 3 types of timers in node - setTimeOut, setInterval, & setImmediate
setTimeOut - runs after certain ms once
setInterval - runs multiple times at certain interval in ms
setImmediate - executes immediately

Event loop, in its first loop goes through all timer related callbacks. Then it moves to next I/O callbacks (in real, it includes most of our node callbacks in). Then setImmediate is runned. Yes you heard it right, setImmediate runs after timers like setTimeOut & setInterval and other I/O callbacks. Then we have close callbacks. Which includes functions that has to be run when callbacks are completed. Now we move to next loop of event loop and this process goes on.


=> Comparing node with php & python:-
- We saw node vs java, c, c++ that these are multi-threaded language. But php & python are single-threaded so whats the difference? 
- Php & python initially used a traditional model that includes apache server, which was a big hit. But, apache would create a new thread for every request we give. It means, for every user we have, there's a new thread. Imagine for apps with millions of users like Facebook, how many threads would there be on apache. Our server would crash immediately. 
- Node model - Though node is single-threaded, it can take thousands of concurrent requests at a time. Due to its ability to delegate the tasks from v8 engine to livuv. It either goes to thread pool or OS via our event loops. All this happens in node itslef no need for a server like apache. 

But now, things are changing, python has instilled event loops for non-blocking I/O. But no language could be as good at non-blocking I/O operations as node is mainly becuase it was created for async programming in mind.

Note that languages are better in their own way. Python is pretty good at complex calcualtions for data analysis & machine learning. Node is not at good at this, not in calcualtions & video processing like stuff. 
- Node is good with servers & web. Where I/O is your main performance issue, node is the best solution.


=> The Observer Pattern:-
Have one subject to be ovserved upon & having multiple observers observing the subject. EXAMPLE - a celebrity having multiple fans. A js button with multiple states like hover, clicked, active, etc.
