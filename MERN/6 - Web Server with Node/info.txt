What is a web server?

- Our client browser made a call to www.facebook.com
- It goes to the DNS server where it finds the IP address of the site.
- The IP address is what the our client gets back.
- This IP address is given to the HTTP server. We call it http because the communication happens via http/https protocol. The server then sends the data back to the client. It could be a json, xml or a txt file.

Note:- The dns call is not something we as developers bother about. Our browser & dns does it their way. They also cache the response (the ip address), we call it DNS caching. So that everytime the browser doesnt has to make a call to dns server for the same site.


=> HTTP responses & requests:-
The calls between browser & the http server happens via APIs. The thing to make sure here is that the browser speaks HTTP language, so our server should also be in that same language. 
Ofcourse, the server internal logic language could be anything like node, python, c, etc.
But what this http language is? How it looks? What the syntax is? 
Here it is:-
GET, POST, PUT, DELETE, HEAD, etc.   (also called http verbs)
Thats it. This is the language of http. Since its so simple, its so widely acceptable. "The language of the web" we call it.


HTTP requests in detail:-
- GET /friends 
Use to get the data of friends from our server

- GET /friends/5
brings us a specific item frm the collection of friends from our server

- POST /messages
post a message in our server. use to write something in our server

- PUT /messages/15
to update a specific message in our collection of server. update whats already there. 

- DELETE /friends/1
delete an item from a collection.

HTTP REQUESTS:-

    METHOD :  could be get, post, etc
    PATH : /messages
    BODY : { text: "hello" }
    HEADERS : host: facebook.com

path is where we want to locate at in our server
body is what mostly we send in post or put as we want to update things in our server
headers are additional data we want to send, its optional. But the host data is something that every app sends to backend. It is basically which server to locate to.


HTTP RESPONSES:-
    HEADERS : Content-type: application/json
    STATUS CODE : Success - 200
    BODY : { text: "hello" }

Headers, same as requests. Content type is something we send in request and in respnse also, specifying what kind of content we are getting
Body is what we get from the server. The data we need to display.
Status code is divided into 100 to 500 series of groups (100 - 599)

100 :- we dont see this much, its used mostly by libraries & browsers. It says, that everything is ok, we can move on.
200 :- The request is succeeded.
300 :- Redirection message. Like the url has been moved to another location kind of
400 :- Client error responses. something we as users messed up. This is not something server knows how to handle it. Most common - 404
418 :- The april fools joke. I'm a teapot. Dont know how to brew coffee.
500 :- Nothing from client, this time the server messed up. 


=> Lets create our first server
    const http = require('http');

    // can specify any port no. mostly for node, its 3000 or 8080
    const PORT = 3000; 

    // http.createServer lets us create a server with 2 args, res and req
    const server = http.createServer((req, res) => {
        // req - has the data & headers that client sent. Its a readable stream
        // res - we can add data & headers to it that needs to send back to client - a writeable stream

        // takes status code as first arg and content-type as second
        res.writeHead(200, {
            'Content-Type': 'text/plain',

            // // lets us pass js obj
            // 'Content-Type': 'application/json'
        })

        // needs to be written for each request we get. Even if its empty. For push & post, we mostly have data in it.
        res.end('Helloo! I am your first server talking..!'); 

        // for application/json content type; res.end() expects string data only
        res.end(JSON.stringify({
            id: "1",
            name: "jainika"
        }))
    });

    server.listen(PORT, () => {
        console.log("Listening on port ", PORT)
    });


=> Creating endpoints

    
// // 2. Creating endpoints

    // another way of creating server. server.on('request') is just alternative of what we did in above exmaple.

    const server = http.createServer();
    server.on('request', (req, res) => {
        // req.url gives us the url and we can create endpoints based on it.
        if(req.url === '/welcome'){
            res.writeHead(200, {
                'Content-Type': 'text/plain' 
            });
            res.end("Hellooo, This is your first server talking..!")
        }
        else if(req.url === '/friends'){
            // another way of defining headers & statusCode. If we dont mention any statuscode, it by defaults to 200.
            res.statusCode = 200;
            res.setHeader('Content-Type', 'text/html')

            // we cant write multiple things in a single res.end(), hence we can use res.write to mention HTML tags, though we'll see a better way for this too
            res.write('<html>')
            res.write('<body>');
            res.write('<ul>')
            res.write('<li> Friend 1 </li>')
            res.write('<li> Friend 2 </li>')
            res.write('</ul>')
            res.write('</body>')
            res.write('</html')

        // res.write("<p>helo</p>") - can even write like this..

            res.end()
        }
        // for 404 error ; module not found. server automatically sends 404 msg, if any of the above endpoints dont meet.
        else{
            res.writeHead(400, {
                'Content-Type': 'text/plain' 
            });
            res.end()
        }
    })

    server.listen(PORT, () => {
        console.log("Listening on port ", PORT)
    });



=> Paramterized URLs:-
// // 3. Parameterized URLs
    const server = http.createServer();
    const friendDB = [
        {
            id: "0",
            name: "N. Modi"
        },
        {
            id: "1",
            name: "Karishma Mehta"
        },
        {
            id: "2",
            name: "Ashneer Grover"
        },
        { 
            id: "3",
            name: "Aman gupta"
        }
    ]

    // another way of adding listener on server
    server.on('request', (req, res) => {
        const items = req.url.split('/')
        if(req.url === '/welcome'){
            res.writeHead(200, {
                'Content-Type': 'text/plain' 
            });
            res.end("Hellooo, This is your first server talking..!")
        }
        else if(items[1] == 'friends' ){
            res.statusCode = 200;
            res.setHeader('Content-Type', 'application/json')
            if(items.length == 3) {
                // we'll get the url param as string, so + will convert it into number
                const frIndex = +items[2]
                res.end(JSON.stringify(friendDB[frIndex]))
            }else{
                res.end(JSON.stringify(friendDB))
            }
        }
        else{
            res.writeHead(400, {
                'Content-Type': 'text/plain' 
            });
            res.end()
        }
    })

- This doesnt look good quality code, does it? Because we have manually written hard-coded steps for every possible url param. THis isnt the ideal way, we have much better ways which we'll explore later.



=> Same Origin Policy:
What is a origin? 
    - https://www.google.com:443/maps
here,
https : protocol
www.google.com : hostname
:443 : Port

Origin is a combination of these 3 things, protocol, host & port. If any of these things changes, its said that origin is changed.
443 - a default port that https uses, for secure communication.

Same origin policy is a security feature of our browser that restricts what page it can load. 
Lets say, we fetched www.google.com. And in google's code, there's a facebook.com call made. Our browser will restrict it. Because the origin changed. 
But in some case, websites allow cross origin, wherein other website lets say google can make a call to facebook.com and its facebook server that handles it in its own way.

- Other example is, when we search something on google, lets say "machine leanring" and we have a wikipedia site comming up. here on clicking on thta site, it takes us to wikipedia's origin. Even though the code is written in google's site, our browser allowed us to move to wikipedia'a page.

- To get a cors error in your console:-
Go to google.com -> open console -> window.fetch("https://en.wikipedia.org) -> make a request -> And you'll get an error becuase the origin we are on is google & we want wikipedia's data. Not allowed

Lets test some knowledge:-
Will the request be succeed or fail?
- A js get request to bank.com?
- A js post request to bank.com?
- Clicking on html link to a video on bank.com?



fail - fetching data to a different origin isnt allowed
succeed - posting data is somehow acceptable by same origin policy as it cant get any private info, so they allow it. as it can only write on server.
succeed - fetching html static resources is allowed. Only scripts are restricted 


=> What is CORS?
- A way to get some relaxation from the same origin policy and make requests to different origin.

eg - wikipedia uses wikimedia as a partner site to get images. And wikipedia can make a request to wikimedia, even though the origin is diff, because it has access-control-allow-origin header in it, with an * value. It lets anyone fetch the data from wikimedia. 

This header, lets us specify a list of sites with diff domains, get access to our server. 

access-control-allow-origin : https://www.google.com   (only google)
access-control-allow-origin : *   (all sites, dont specify this in production. any site can get your data easily)

It has whitelisting and blacklisting approach
- whitelisting : explicitly allowing access to a particular service
- blacklisting : allows everyone, except a list of particular services specified.

NOTE: This is all done by browsers. This feature is of a browser & not of any particular language.


=> Posting data to server

    if(req.method === 'POST' && items[1] == 'friends' ){
        req.on("data", (data) => {
            const newFriend = data.toString()
            console.log(`request data: ${newFriend}`)
            friendDB.push(JSON.parse(newFriend))
        })
        
    }

Here, req is a stream on which we can emit events, and so we are emitting data event which gives us data that is passed by the browser. Note here, browser sends data in json string, we get it in buffer. So we convert it back to toString and while pushing the data in our array we need js obj, so converting it via json.parse.
A lot of converting is happening, isnt it? Dont worry a better way of writing node is coming soon.

To check this function, go to browser console:-

    fetch('http://localhost:3000/friends', {
        method: 'POST',
        body: JSON.stringify({ id: 3, name: 'Ryan Dahl' })
    });

We can call a fetch function to our browser like above, you might get cors error but it'll work anyways. If you go to the /friends endpoint in your browser, you'll see your new friend.

    
    // // 4. POsting data to server
    const server = http.createServer();
    const friendDB = [
        {
            id: "0",
            name: "N. Modi"
        },
        {
            id: "1",
            name: "Karishma Mehta"
        },
        {
            id: "2",
            name: "Ashneer Grover"
        },
        { 
            id: "3",
            name: "Aman gupta"
        }
    ]
    server.on('request', (req, res) => {
        const items = req.url.split('/')

        if(req.method === 'POST' && items[1] == 'friends' ){
            // we get data as a buffer so converting it to string.
            req.on("data", (data) => {
                const newFriend = data.toString()
                console.log(`request data: ${newFriend}`)
                friendDB.push(JSON.parse(newFriend))
            });
            // readable.pipe(writeable) - here, we'll get the data we passed in browser.
            req.pipe(res) // - with pipe we can remove the .end() thing, pipe does it for us. So its optional.
            res.end();
        }
        if(req.method === 'GET' && req.url === '/welcome'){
            res.writeHead(200, {
                'Content-Type': 'text/plain' 
            });
            res.end("Hellooo, This is your first server talking..!")
        }
    })

In browser console,
    fetch('http://localhost:3000/friends', {
        method: 'POST',
        body: JSON.stringify({ id: 6, name: 'Hooper'})
    })
    .then((response) => response.json())
    .then((friend) => console.log(friend));


- MAKE SURE that your browser is having the localhost:3000/friends route, otherwise you might gte cors error in console, in that fetch request. 
- req.on("data") is triggered when there's data in the request, passed from browser. and in the data object, we received the data. which is passed in form of a buffer. Hence, we convert it to toString function. From string, we are converting it to json, to get a javascript obj, so that we can perform js operations on it.
- Its always recommend to use req.method when we have multiple methods available in our code.